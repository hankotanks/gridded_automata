= Gridded Automata

This is a library for rendering discrete cellular automata using compute shaders. 
Users provide a state function (written in _WGSL_) that returns a cell's new state based on its current state and that of its neighbors. The simulation speed, the way cells are colored, and the type of neighborhood can be tweaked through config options.

Automata cell data can be read from `PGM` image files, which can be in ASCII or binary format (`P2` & `P5` as described https://en.wikipedia.org/wiki/Netpbm[here]). Data can also be read from any other type of image if the library's `from_image` feature is enabled. Note that colors are assigned values in the order they are encountered. For this reason, it's best to provide a "color legend" in the image's topmost row, from left-to-right.

== Examples

A number of classic automata are included as binaries, intended to showcase the library.
Run them with `cargo run --bin [name]`

.*Binaries*
[horizontal]
`cgol` :: Conway's Game of Life
`ww` :: https://mathworld.wolfram.com/WireWorld.html[Wire World] (loads cells from a `PGM` file)
`lant` :: Langton's Ant
`seeds` :: Seeds
`bb` :: https://conwaylife.com/wiki/OCA:Brian's_Brain[Brian's Brain]

== Neighborhoods

The library distinguishes between two types of neighborhoods, Moore and Von-Neumann. These are represented by the same _WGSL_ data type; all the same functions apply to them. Their layouts can be found below:

.*Moore*
----
4 0 5
1 · 2
6 3 7
----

.*Von Neumann*
----
  0 
1 · 2
  3 
----

== The State Function

Each generation, a 'state' function is called on each cell in the simulation. Here's the one in `seeds.wgsl`:

----
fn main(neighborhood: Neighborhood, state: u32) -> u32 {
    if(state == 0u && living(neighborhood) == 2u) {
        return 1u;
    } 
    
    return 0u;
}
----

All state functions must have this method signature. When compiling the compute shader, this function is placed after a header that contains a number of helper functions.

.*Here's some of them...*
[horizontal]
`living(Neighborhood) -> u32` :: Returns the number of non-zero cells in the neighborhood.
`matching(Neighborhood, u32) -> u32` :: Returns the number of cells with the given state in the neighborhood.
`up(Neighborhood) -> u32` :: Returns the cell above the current cell.
`left(Neighborhood) -> u32` :: Returns the cell to the left of the current cell.
`right(Neighborhood) -> u32` :: Returns the cell to the right of the current cell.
`down(Neighborhood) -> u32` :: Returns the cell beneath the current cell.